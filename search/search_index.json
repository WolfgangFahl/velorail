{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"velorail API Documentation","text":""},{"location":"#velorail.gpxviewer","title":"<code>gpxviewer</code>","text":"<p>Created on 2025-01-17</p> <p>@author: wf</p>"},{"location":"#velorail.gpxviewer.GPXViewer","title":"<code>GPXViewer</code>","text":"<p>display a given gpx file</p> Source code in <code>velorail/gpxviewer.py</code> <pre><code>class GPXViewer:\n    \"\"\"\n    display a given gpx file\n    \"\"\"\n\n    samples = {\n        \"Mountain bike loop at Middlesex Fells reservation.\": \"https://www.topografix.com/fells_loop.gpx\",\n        \"Via Verde de Arditurri\": \"https://www.bahntrassenradwege.de/images/Spanien/Baskenland/V-v-de-arditurri/Arditurri2.gpx\",\n        \"V\u00eda Verde del Fc Vasco Navarro\": \"https://ebike.bitplan.com/images/ebike/e/ec/VV-del-FC-Vasco-Navarro_fdmi1644.gpx\",\n    }\n    default_center = [51.4934, 0.0098]  # greenwich\n    default_zoom = 11\n\n    @classmethod\n    def from_url(cls, gpx_url) -&gt; \"GPXViewer\":\n        viewer = cls()\n        viewer.load_gpx(gpx_url)\n        return viewer\n\n    def __init__(self, args: argparse.Namespace = None):\n        \"\"\"\n        constructor\n\n        Args:\n            args(argparse.Namespace): command line arguments\n        \"\"\"\n        self.args = args\n        self.tour = None\n        self.leg_styles = LegStyles.default()\n        self.set_center()\n        if args:\n            self.debug = args.debug\n            self.token = args.token\n            self.center = args.center\n            self.zoom = args.zoom\n            if self.args.gpx:\n                self.load_gpx(self.args.gpx)\n        else:\n            self.zoom = GPXViewer.default_zoom\n            self.center = GPXViewer.default_center\n\n    def load_gpx(self, gpx_url: str):\n        \"\"\"\n        load the given gpx file\n        \"\"\"\n        response = requests.get(gpx_url)\n        self.gpx = gpxpy.parse(response.text)\n        self.get_points(self.gpx)\n        return self.gpx\n\n    def set_center(self):\n        \"\"\"\n        Calculate and set the center and bounding box based on tour legs\n        \"\"\"\n\n        if self.tour and self.tour.legs:\n            points = []\n            for leg in self.tour.legs:\n                points.append(leg.start.coordinates)\n                points.append(leg.end.coordinates)\n            # Wrong order: lats, lons need to be extracted after zipping\n            lats = [p[0] for p in points]\n            lons = [p[1] for p in points]\n            self.bounding_box = (min(lats), max(lats), min(lons), max(lons))\n            self.center = ((min(lats) + max(lats)) / 2, (min(lons) + max(lons)) / 2)\n        else:\n            self.center = self.default_center\n            self.bounding_box = None\n        return self.center\n\n    def add_leg(\n        self,\n        start_point,\n        end_point,\n        leg_type: str,\n        add_end_point: bool = False,\n        url: Optional[str] = None,\n    ):\n        \"\"\"\n        Add a leg to the tour\n\n        Args:\n            start_point: GPX point for start of leg\n            end_point: GPX point for end of leg\n            leg_type: Type of leg (e.g., \"bike\", \"train\", \"car\")\n            add_end_point: Whether to add the end point (True for last leg)\n            url: Optional URL associated with the leg\n        \"\"\"\n        if self.tour is None:\n            self.tour = Tour(name=\"GPX Tour\")\n\n        # Create locations\n        start_loc = Loc(\n            id=str(len(self.tour.legs)),\n            name=start_point.name if hasattr(start_point, \"name\") else None,\n            coordinates=(start_point.latitude, start_point.longitude),\n        )\n        end_loc = Loc(\n            id=str(len(self.tour.legs) + 1),\n            name=end_point.name if hasattr(end_point, \"name\") else None,\n            coordinates=(end_point.latitude, end_point.longitude),\n        )\n\n        # Create and add leg\n        leg = Leg(leg_type=leg_type, start=start_loc, end=end_loc, url=url)\n        self.tour.legs.append(leg)\n\n    def get_points(self, gpx, way_points_fallback: bool = False):\n        \"\"\"\n        Extract waypoints and legs from the GPX object and create a tour\n        \"\"\"\n        self.tour = Tour(name=\"GPX Tour\")\n\n        # Process routes\n        for route in gpx.routes:\n            for i in range(len(route.points) - 1):\n                url = route.link.href if route.link else None\n                is_last = i == len(route.points) - 2\n                self.add_leg(\n                    route.points[i],\n                    route.points[i + 1],\n                    \"bike\",  # Default to bike for routes\n                    add_end_point=is_last,\n                    url=url,\n                )\n\n        # Process tracks\n        for track in gpx.tracks:\n            for segment in track.segments:\n                for i in range(len(segment.points) - 1):\n                    is_last = i == len(segment.points) - 2\n                    self.add_leg(\n                        segment.points[i],\n                        segment.points[i + 1],\n                        \"bike\",  # Default to bike for tracks\n                        add_end_point=is_last,\n                    )\n\n        prev_loc = None\n        # Handle waypoints if no legs were created and fallback is active\n        if not self.tour.legs and gpx.waypoints and way_points_fallback:\n            for i, waypoint in enumerate(gpx.waypoints):\n                loc = Loc(\n                    id=str(i),\n                    name=waypoint.name,\n                    coordinates=(waypoint.latitude, waypoint.longitude),\n                    notes=waypoint.description,\n                )\n                if i &gt; 0:\n                    leg = Leg(\n                        leg_type=\"bike\",\n                        start=prev_loc,\n                        end=loc,\n                        url=waypoint.link.href if waypoint.link else None,\n                    )\n                    self.tour.legs.append(leg)\n                prev_loc = loc\n\n    def parse_lines(self, lines: str):\n        \"\"\"\n        Parse the 'lines' parameter into route segments.\n\n        Args:\n            lines (str): The input string containing routes in the format:\n                \"By bike: 51.243931\u00b0 N, 6.520022\u00b0 E, 51.269222\u00b0 N, 6.625467\u00b0 E:\"\n\n        Returns:\n            Tour: Created tour from the parsed coordinates\n        \"\"\"\n        coordinate_pattern = r\"(\\d+\\.\\d+)\u00b0 ([NS]), (\\d+\\.\\d+)\u00b0 ([EW])\"\n        route_segments = lines.split(\":\")\n        self.tour = Tour(name=\"Parsed Tour\")\n\n        for segment in route_segments:\n            segment = segment.strip()\n\n            # Extract leg type (e.g., \"bike\", \"train\")\n            leg_type_match = re.match(r\"By (\\w+)\u2192\", segment)\n            if leg_type_match:\n                leg_type = leg_type_match.group(1).lower()\n                pass\n            else:\n                leg_type = \"bike\"\n\n            points = re.findall(coordinate_pattern, segment)\n            if points:\n                prev_loc = None\n                for i, (lat, ns, lon, ew) in enumerate(points):\n                    lat_val = float(lat) * (-1 if ns == \"S\" else 1)\n                    lon_val = float(lon) * (-1 if ew == \"W\" else 1)\n\n                    loc = Loc(\n                        id=str(len(self.tour.legs) + i),\n                        name=None,\n                        coordinates=(lat_val, lon_val),\n                    )\n\n                    if prev_loc:\n                        leg = Leg(leg_type=leg_type, start=prev_loc, end=loc)\n                        self.tour.legs.append(leg)\n                    prev_loc = loc\n\n        if not self.tour.legs:\n            raise ValueError(\"No valid routes found in the input lines.\")\n\n        return self.tour\n\n    def parse_lines_and_show(self, lines: str, zoom: int = None):\n        \"\"\"\n        Parse lines and display them on the map\n        \"\"\"\n        self.parse_lines(lines)\n        self.show(zoom=zoom)\n\n    def show(self, zoom: int = None, center=None):\n        \"\"\"\n        Show tour with styled paths\n        \"\"\"\n        if zoom is None:\n            zoom = self.zoom\n        if center is None:\n            center = self.set_center()\n\n        self.map = LeafletMap(center=center, zoom=zoom)\n        if self.tour:\n            self.map.draw_tour(self.tour, self.leg_styles)\n</code></pre>"},{"location":"#velorail.gpxviewer.GPXViewer.__init__","title":"<code>__init__(args=None)</code>","text":"<p>constructor</p> <p>Parameters:</p> Name Type Description Default <code>args(argparse.Namespace)</code> <p>command line arguments</p> required Source code in <code>velorail/gpxviewer.py</code> <pre><code>def __init__(self, args: argparse.Namespace = None):\n    \"\"\"\n    constructor\n\n    Args:\n        args(argparse.Namespace): command line arguments\n    \"\"\"\n    self.args = args\n    self.tour = None\n    self.leg_styles = LegStyles.default()\n    self.set_center()\n    if args:\n        self.debug = args.debug\n        self.token = args.token\n        self.center = args.center\n        self.zoom = args.zoom\n        if self.args.gpx:\n            self.load_gpx(self.args.gpx)\n    else:\n        self.zoom = GPXViewer.default_zoom\n        self.center = GPXViewer.default_center\n</code></pre>"},{"location":"#velorail.gpxviewer.GPXViewer.add_leg","title":"<code>add_leg(start_point, end_point, leg_type, add_end_point=False, url=None)</code>","text":"<p>Add a leg to the tour</p> <p>Parameters:</p> Name Type Description Default <code>start_point</code> <p>GPX point for start of leg</p> required <code>end_point</code> <p>GPX point for end of leg</p> required <code>leg_type</code> <code>str</code> <p>Type of leg (e.g., \"bike\", \"train\", \"car\")</p> required <code>add_end_point</code> <code>bool</code> <p>Whether to add the end point (True for last leg)</p> <code>False</code> <code>url</code> <code>Optional[str]</code> <p>Optional URL associated with the leg</p> <code>None</code> Source code in <code>velorail/gpxviewer.py</code> <pre><code>def add_leg(\n    self,\n    start_point,\n    end_point,\n    leg_type: str,\n    add_end_point: bool = False,\n    url: Optional[str] = None,\n):\n    \"\"\"\n    Add a leg to the tour\n\n    Args:\n        start_point: GPX point for start of leg\n        end_point: GPX point for end of leg\n        leg_type: Type of leg (e.g., \"bike\", \"train\", \"car\")\n        add_end_point: Whether to add the end point (True for last leg)\n        url: Optional URL associated with the leg\n    \"\"\"\n    if self.tour is None:\n        self.tour = Tour(name=\"GPX Tour\")\n\n    # Create locations\n    start_loc = Loc(\n        id=str(len(self.tour.legs)),\n        name=start_point.name if hasattr(start_point, \"name\") else None,\n        coordinates=(start_point.latitude, start_point.longitude),\n    )\n    end_loc = Loc(\n        id=str(len(self.tour.legs) + 1),\n        name=end_point.name if hasattr(end_point, \"name\") else None,\n        coordinates=(end_point.latitude, end_point.longitude),\n    )\n\n    # Create and add leg\n    leg = Leg(leg_type=leg_type, start=start_loc, end=end_loc, url=url)\n    self.tour.legs.append(leg)\n</code></pre>"},{"location":"#velorail.gpxviewer.GPXViewer.get_points","title":"<code>get_points(gpx, way_points_fallback=False)</code>","text":"<p>Extract waypoints and legs from the GPX object and create a tour</p> Source code in <code>velorail/gpxviewer.py</code> <pre><code>def get_points(self, gpx, way_points_fallback: bool = False):\n    \"\"\"\n    Extract waypoints and legs from the GPX object and create a tour\n    \"\"\"\n    self.tour = Tour(name=\"GPX Tour\")\n\n    # Process routes\n    for route in gpx.routes:\n        for i in range(len(route.points) - 1):\n            url = route.link.href if route.link else None\n            is_last = i == len(route.points) - 2\n            self.add_leg(\n                route.points[i],\n                route.points[i + 1],\n                \"bike\",  # Default to bike for routes\n                add_end_point=is_last,\n                url=url,\n            )\n\n    # Process tracks\n    for track in gpx.tracks:\n        for segment in track.segments:\n            for i in range(len(segment.points) - 1):\n                is_last = i == len(segment.points) - 2\n                self.add_leg(\n                    segment.points[i],\n                    segment.points[i + 1],\n                    \"bike\",  # Default to bike for tracks\n                    add_end_point=is_last,\n                )\n\n    prev_loc = None\n    # Handle waypoints if no legs were created and fallback is active\n    if not self.tour.legs and gpx.waypoints and way_points_fallback:\n        for i, waypoint in enumerate(gpx.waypoints):\n            loc = Loc(\n                id=str(i),\n                name=waypoint.name,\n                coordinates=(waypoint.latitude, waypoint.longitude),\n                notes=waypoint.description,\n            )\n            if i &gt; 0:\n                leg = Leg(\n                    leg_type=\"bike\",\n                    start=prev_loc,\n                    end=loc,\n                    url=waypoint.link.href if waypoint.link else None,\n                )\n                self.tour.legs.append(leg)\n            prev_loc = loc\n</code></pre>"},{"location":"#velorail.gpxviewer.GPXViewer.load_gpx","title":"<code>load_gpx(gpx_url)</code>","text":"<p>load the given gpx file</p> Source code in <code>velorail/gpxviewer.py</code> <pre><code>def load_gpx(self, gpx_url: str):\n    \"\"\"\n    load the given gpx file\n    \"\"\"\n    response = requests.get(gpx_url)\n    self.gpx = gpxpy.parse(response.text)\n    self.get_points(self.gpx)\n    return self.gpx\n</code></pre>"},{"location":"#velorail.gpxviewer.GPXViewer.parse_lines","title":"<code>parse_lines(lines)</code>","text":"<p>Parse the 'lines' parameter into route segments.</p> <p>Parameters:</p> Name Type Description Default <code>lines</code> <code>str</code> <p>The input string containing routes in the format: \"By bike: 51.243931\u00b0 N, 6.520022\u00b0 E, 51.269222\u00b0 N, 6.625467\u00b0 E:\"</p> required <p>Returns:</p> Name Type Description <code>Tour</code> <p>Created tour from the parsed coordinates</p> Source code in <code>velorail/gpxviewer.py</code> <pre><code>def parse_lines(self, lines: str):\n    \"\"\"\n    Parse the 'lines' parameter into route segments.\n\n    Args:\n        lines (str): The input string containing routes in the format:\n            \"By bike: 51.243931\u00b0 N, 6.520022\u00b0 E, 51.269222\u00b0 N, 6.625467\u00b0 E:\"\n\n    Returns:\n        Tour: Created tour from the parsed coordinates\n    \"\"\"\n    coordinate_pattern = r\"(\\d+\\.\\d+)\u00b0 ([NS]), (\\d+\\.\\d+)\u00b0 ([EW])\"\n    route_segments = lines.split(\":\")\n    self.tour = Tour(name=\"Parsed Tour\")\n\n    for segment in route_segments:\n        segment = segment.strip()\n\n        # Extract leg type (e.g., \"bike\", \"train\")\n        leg_type_match = re.match(r\"By (\\w+)\u2192\", segment)\n        if leg_type_match:\n            leg_type = leg_type_match.group(1).lower()\n            pass\n        else:\n            leg_type = \"bike\"\n\n        points = re.findall(coordinate_pattern, segment)\n        if points:\n            prev_loc = None\n            for i, (lat, ns, lon, ew) in enumerate(points):\n                lat_val = float(lat) * (-1 if ns == \"S\" else 1)\n                lon_val = float(lon) * (-1 if ew == \"W\" else 1)\n\n                loc = Loc(\n                    id=str(len(self.tour.legs) + i),\n                    name=None,\n                    coordinates=(lat_val, lon_val),\n                )\n\n                if prev_loc:\n                    leg = Leg(leg_type=leg_type, start=prev_loc, end=loc)\n                    self.tour.legs.append(leg)\n                prev_loc = loc\n\n    if not self.tour.legs:\n        raise ValueError(\"No valid routes found in the input lines.\")\n\n    return self.tour\n</code></pre>"},{"location":"#velorail.gpxviewer.GPXViewer.parse_lines_and_show","title":"<code>parse_lines_and_show(lines, zoom=None)</code>","text":"<p>Parse lines and display them on the map</p> Source code in <code>velorail/gpxviewer.py</code> <pre><code>def parse_lines_and_show(self, lines: str, zoom: int = None):\n    \"\"\"\n    Parse lines and display them on the map\n    \"\"\"\n    self.parse_lines(lines)\n    self.show(zoom=zoom)\n</code></pre>"},{"location":"#velorail.gpxviewer.GPXViewer.set_center","title":"<code>set_center()</code>","text":"<p>Calculate and set the center and bounding box based on tour legs</p> Source code in <code>velorail/gpxviewer.py</code> <pre><code>def set_center(self):\n    \"\"\"\n    Calculate and set the center and bounding box based on tour legs\n    \"\"\"\n\n    if self.tour and self.tour.legs:\n        points = []\n        for leg in self.tour.legs:\n            points.append(leg.start.coordinates)\n            points.append(leg.end.coordinates)\n        # Wrong order: lats, lons need to be extracted after zipping\n        lats = [p[0] for p in points]\n        lons = [p[1] for p in points]\n        self.bounding_box = (min(lats), max(lats), min(lons), max(lons))\n        self.center = ((min(lats) + max(lats)) / 2, (min(lons) + max(lons)) / 2)\n    else:\n        self.center = self.default_center\n        self.bounding_box = None\n    return self.center\n</code></pre>"},{"location":"#velorail.gpxviewer.GPXViewer.show","title":"<code>show(zoom=None, center=None)</code>","text":"<p>Show tour with styled paths</p> Source code in <code>velorail/gpxviewer.py</code> <pre><code>def show(self, zoom: int = None, center=None):\n    \"\"\"\n    Show tour with styled paths\n    \"\"\"\n    if zoom is None:\n        zoom = self.zoom\n    if center is None:\n        center = self.set_center()\n\n    self.map = LeafletMap(center=center, zoom=zoom)\n    if self.tour:\n        self.map.draw_tour(self.tour, self.leg_styles)\n</code></pre>"},{"location":"#velorail.gpxviewer_server","title":"<code>gpxviewer_server</code>","text":"<p>Created on 2025-01-18</p> <p>@author: wf</p>"},{"location":"#velorail.gpxviewer_server.clean_smw_artifacts","title":"<code>clean_smw_artifacts(input_str)</code>","text":"<p>Remove SMW artifacts ([[SMW::on]] and [[SMW::off]]) from the input string.</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string containing SMW artifacts.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Cleaned string without SMW markers.</p> Source code in <code>velorail/gpxviewer_server.py</code> <pre><code>def clean_smw_artifacts(input_str: str) -&gt; str:\n    \"\"\"\n    Remove SMW artifacts ([[SMW::on]] and [[SMW::off]]) from the input string.\n\n    Args:\n        input_str (str): Input string containing SMW artifacts.\n\n    Returns:\n        str: Cleaned string without SMW markers.\n    \"\"\"\n    # Regex to match and remove SMW markers\n    return re.sub(r\"\\[\\[SMW::(on|off)\\]\\]\", \"\", input_str)\n</code></pre>"},{"location":"#velorail.gpxviewer_server.gpx","title":"<code>gpx(gpx=None, auth_token=None, zoom=GPXViewer.default_zoom)</code>","text":"<p>GPX viewer page with optional gpx_url and auth_token.</p> Source code in <code>velorail/gpxviewer_server.py</code> <pre><code>@ui.page(\"/\")\ndef gpx(gpx: str = None, auth_token: str = None, zoom: int = GPXViewer.default_zoom):\n    \"\"\"\n    GPX viewer page with optional gpx_url and auth_token.\n    \"\"\"\n    global viewer\n    if not viewer:\n        ui.label(\"Error: Viewer not initialized\")\n        return\n\n    if viewer.args.token and auth_token != viewer.args.token:\n        ui.label(\"Error: Invalid authentication token\")\n        return\n\n    gpx_to_use = gpx if gpx else viewer.args.gpx\n    if gpx_to_use:\n        viewer.load_gpx(gpx_to_use)\n        viewer.show(zoom=zoom)\n    else:\n        ui.label(\n            \"Please provide a GPX file via 'gpx' query parameter or the command line.\"\n        )\n</code></pre>"},{"location":"#velorail.gpxviewer_server.initialize_viewer","title":"<code>initialize_viewer()</code>","text":"<p>Initialize the GPXViewer with parsed arguments.</p> Source code in <code>velorail/gpxviewer_server.py</code> <pre><code>def initialize_viewer():\n    \"\"\"\n    Initialize the GPXViewer with parsed arguments.\n    \"\"\"\n    global viewer\n    parser = GPXViewer.get_parser()\n    args = parser.parse_args()\n    viewer = GPXViewer(args=args)\n</code></pre>"},{"location":"#velorail.gpxviewer_server.lines_page","title":"<code>lines_page(lines=None, auth_token=None, zoom=GPXViewer.default_zoom)</code>","text":"<p>Endpoint to display routes based on 'lines' parameter.</p> Source code in <code>velorail/gpxviewer_server.py</code> <pre><code>@ui.page(\"/lines\")\ndef lines_page(\n    lines: str = None, auth_token: str = None, zoom: int = GPXViewer.default_zoom\n):\n    \"\"\"\n    Endpoint to display routes based on 'lines' parameter.\n    \"\"\"\n    global viewer\n    if not viewer:\n        ui.label(\"Error: Viewer not initialized\")\n        return\n\n    if viewer.args.token and auth_token != viewer.args.token:\n        ui.label(\"Error: Invalid authentication token\")\n        return\n\n    if not lines:\n        ui.label(\"Error: No 'lines' parameter provided\")\n        return\n\n    # Clean the lines parameter to remove SMW artifacts\n    cleaned_lines = clean_smw_artifacts(lines)\n\n    # Delegate logic to GPXViewer\n    try:\n        viewer.parse_lines_and_show(cleaned_lines, zoom=zoom)\n    except ValueError as e:\n        ui.label(f\"Error processing lines: {e}\")\n</code></pre>"},{"location":"#velorail.gpxviewer_server.main","title":"<code>main()</code>","text":"<p>Entry point for gpxviewer.</p> Source code in <code>velorail/gpxviewer_server.py</code> <pre><code>def main():\n    \"\"\"\n    Entry point for gpxviewer.\n    \"\"\"\n    initialize_viewer()\n    ui.run(port=viewer.args.port, title=\"GPX Viewer\")\n</code></pre>"},{"location":"#velorail.locfind","title":"<code>locfind</code>","text":"<p>Created on 2025-02-01</p> <p>@author: th</p>"},{"location":"#velorail.locfind.LocFinder","title":"<code>LocFinder</code>","text":"<p>Set of methods to lookup different location types</p> Source code in <code>velorail/locfind.py</code> <pre><code>class LocFinder:\n    \"\"\"\n    Set of methods to lookup different location types\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        constructor\n        \"\"\"\n        endpoint_path = Path(__file__).parent / \"resources\" / \"endpoints.yaml\"\n        query_path = Path(__file__).parent / \"resources\" / \"queries\" / \"locations.yaml\"\n        if not query_path.is_file():\n            raise FileNotFoundError(f\"LocFinder queries file not found: {query_path}\")\n        self.query_manager = QueryManager(\n            lang=\"sparql\", queriesPath=query_path.as_posix()\n        )\n        self.endpoint_manager = EndpointManager.getEndpoints(endpoint_path.as_posix())\n\n    def query(self,query_name:str,param_dict:dict={},endpoint:str=\"wikidata-qlever\"):\n        \"\"\"\n        get the result of the given query\n        \"\"\"\n        query: Query = self.query_manager.queriesByName.get(query_name)\n        sparql_endpoint = self.endpoint_manager[endpoint]\n        endpoint = SPARQL(sparql_endpoint.endpoint)\n        qres = endpoint.queryAsListOfDicts(query.query,param_dict=param_dict)\n        return qres\n\n    def get_wikidata_geo(self, qid: str) -&gt; WikidataGeoItem:\n        \"\"\"\n        Get geographical coordinates and metadata for a Wikidata item\n\n        Args:\n            qid: Wikidata QID of the item\n\n        Returns:\n            WikidataGeoItem with location data and metadata\n        \"\"\"\n        lod = self.query(query_name=\"WikidataGeo\", param_dict={\"qid\": qid})\n        if len(lod) &gt;= 1:\n            record = lod[0]\n            record[\"qid\"] = qid  # Add qid to record for WikidataGeoItem creation\n            return WikidataGeoItem.from_record(record)\n        return None\n\n    def get_all_train_stations(self):\n        lod = self.query(query_name=\"AllTrainStations\")\n        return lod\n\n\n    def get_train_stations_by_coordinates(\n        self, latitude: float, longitude: float, radius: float\n    ):\n        \"\"\"\n        Get all train stations within the given radius around the given latitude and longitude\n        \"\"\"\n        lod = self.get_all_train_stations()\n        df = pd.DataFrame.from_records(lod)\n        # Haversine formula components\n        lat1, lon1 = np.radians(latitude), np.radians(longitude)\n        lat2, lon2 = np.radians(df[\"lat\"]), np.radians(df[\"long\"])\n\n        # Differences in coordinates\n        dlat = lat2 - lat1\n        dlon = lon2 - lon1\n\n        # Haversine formula\n        a = np.sin(dlat / 2) ** 2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon / 2) ** 2\n        c = 2 * np.arcsin(np.sqrt(a))\n        r = 6371  # Radius of Earth in kilometers\n\n        # Calculate distances\n        distances = c * r\n\n        # Add distances to dataframe\n        df_with_distances = df.copy()\n        df_with_distances[\"distance_km\"] = distances\n\n        # Filter points within radius\n        points_within_radius = df_with_distances[\n            df_with_distances[\"distance_km\"] &lt;= radius\n        ].copy()\n\n        # Sort by distance\n        points_within_radius = points_within_radius.sort_values(\"distance_km\")\n\n        return points_within_radius\n</code></pre>"},{"location":"#velorail.locfind.LocFinder.__init__","title":"<code>__init__()</code>","text":"<p>constructor</p> Source code in <code>velorail/locfind.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    constructor\n    \"\"\"\n    endpoint_path = Path(__file__).parent / \"resources\" / \"endpoints.yaml\"\n    query_path = Path(__file__).parent / \"resources\" / \"queries\" / \"locations.yaml\"\n    if not query_path.is_file():\n        raise FileNotFoundError(f\"LocFinder queries file not found: {query_path}\")\n    self.query_manager = QueryManager(\n        lang=\"sparql\", queriesPath=query_path.as_posix()\n    )\n    self.endpoint_manager = EndpointManager.getEndpoints(endpoint_path.as_posix())\n</code></pre>"},{"location":"#velorail.locfind.LocFinder.get_train_stations_by_coordinates","title":"<code>get_train_stations_by_coordinates(latitude, longitude, radius)</code>","text":"<p>Get all train stations within the given radius around the given latitude and longitude</p> Source code in <code>velorail/locfind.py</code> <pre><code>def get_train_stations_by_coordinates(\n    self, latitude: float, longitude: float, radius: float\n):\n    \"\"\"\n    Get all train stations within the given radius around the given latitude and longitude\n    \"\"\"\n    lod = self.get_all_train_stations()\n    df = pd.DataFrame.from_records(lod)\n    # Haversine formula components\n    lat1, lon1 = np.radians(latitude), np.radians(longitude)\n    lat2, lon2 = np.radians(df[\"lat\"]), np.radians(df[\"long\"])\n\n    # Differences in coordinates\n    dlat = lat2 - lat1\n    dlon = lon2 - lon1\n\n    # Haversine formula\n    a = np.sin(dlat / 2) ** 2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon / 2) ** 2\n    c = 2 * np.arcsin(np.sqrt(a))\n    r = 6371  # Radius of Earth in kilometers\n\n    # Calculate distances\n    distances = c * r\n\n    # Add distances to dataframe\n    df_with_distances = df.copy()\n    df_with_distances[\"distance_km\"] = distances\n\n    # Filter points within radius\n    points_within_radius = df_with_distances[\n        df_with_distances[\"distance_km\"] &lt;= radius\n    ].copy()\n\n    # Sort by distance\n    points_within_radius = points_within_radius.sort_values(\"distance_km\")\n\n    return points_within_radius\n</code></pre>"},{"location":"#velorail.locfind.LocFinder.get_wikidata_geo","title":"<code>get_wikidata_geo(qid)</code>","text":"<p>Get geographical coordinates and metadata for a Wikidata item</p> <p>Parameters:</p> Name Type Description Default <code>qid</code> <code>str</code> <p>Wikidata QID of the item</p> required <p>Returns:</p> Type Description <code>WikidataGeoItem</code> <p>WikidataGeoItem with location data and metadata</p> Source code in <code>velorail/locfind.py</code> <pre><code>def get_wikidata_geo(self, qid: str) -&gt; WikidataGeoItem:\n    \"\"\"\n    Get geographical coordinates and metadata for a Wikidata item\n\n    Args:\n        qid: Wikidata QID of the item\n\n    Returns:\n        WikidataGeoItem with location data and metadata\n    \"\"\"\n    lod = self.query(query_name=\"WikidataGeo\", param_dict={\"qid\": qid})\n    if len(lod) &gt;= 1:\n        record = lod[0]\n        record[\"qid\"] = qid  # Add qid to record for WikidataGeoItem creation\n        return WikidataGeoItem.from_record(record)\n    return None\n</code></pre>"},{"location":"#velorail.locfind.LocFinder.query","title":"<code>query(query_name, param_dict={}, endpoint='wikidata-qlever')</code>","text":"<p>get the result of the given query</p> Source code in <code>velorail/locfind.py</code> <pre><code>def query(self,query_name:str,param_dict:dict={},endpoint:str=\"wikidata-qlever\"):\n    \"\"\"\n    get the result of the given query\n    \"\"\"\n    query: Query = self.query_manager.queriesByName.get(query_name)\n    sparql_endpoint = self.endpoint_manager[endpoint]\n    endpoint = SPARQL(sparql_endpoint.endpoint)\n    qres = endpoint.queryAsListOfDicts(query.query,param_dict=param_dict)\n    return qres\n</code></pre>"},{"location":"#velorail.locfind.WikidataGeoItem","title":"<code>WikidataGeoItem</code>","text":"<p>Dataclass for storing Wikidata geographical location data with labels</p> Source code in <code>velorail/locfind.py</code> <pre><code>@lod_storable\nclass WikidataGeoItem:\n    \"\"\"\n    Dataclass for storing Wikidata geographical location data with labels\n    \"\"\"\n    qid: str\n    lat: float\n    lon: float\n    label: Optional[str]=None\n    description: Optional[str]=None\n\n    def as_wd_link(self)-&gt;Link:\n        text = f\"\"\"{self.label}({self.qid})\u261e{self.description}\"\"\"\n        wd_link = Link.create(f\"https://www.wikidata.org/wiki/{self.qid}\", text)\n        return wd_link\n\n    def get_map_links(self, leg_styles:Optional[LegStyles]=None, zoom:int=14) -&gt; str:\n        \"\"\"\n        Get HTML markup with icons grouped by map type\n        \"\"\"\n        if leg_styles is None:\n            leg_styles = LegStyles.default()\n\n        map_links = {\n            \"openstreetmap.org\": [\"car\", \"bus\", \"plane\"],\n            \"opencyclemap.org\": [\"bike\"],\n            \"openrailwaymap.org\": [\"train\"],\n            \"map.openseamap.org\": [\"ferry\"],\n            \"hiking.waymarkedtrails.org\": [\"foot\"]\n        }\n\n        markup = \"\"\n        delim=\"\"\n        for map_url, leg_types in map_links.items():\n            icons=\"\"\n            for leg_type in leg_types:\n                leg_style=leg_styles.get_style(leg_type)\n                icons+=leg_style.utf8_icon\n            tooltip = f\"{','.join(leg_types)} map\"\n            if \"car\" in leg_types:\n                url = f\"https://{map_url}/#map={zoom}/{self.lat}/{self.lon}\"\n            elif \"foot\" in leg_types:\n                url = f\"https://{map_url}/#?map={zoom}/{self.lat}/{self.lon}\"\n            else:\n                url = f\"https://{map_url}/?zoom={zoom}&amp;lat={self.lat}&amp;lon={self.lon}\"\n            link=Link.create(url, text=icons, tooltip=tooltip, target=\"_blank\")\n            markup+=link+delim\n            delim=\"\\n\"\n        return markup\n\n    @property\n    def osm_url(self, map_type:str= \"street\", zoom: int = 15) -&gt; str:\n        \"\"\"\n        Get OpenStreetMap URL for this location\n\n        Args:\n            zoom: Zoom level (default=15)\n\n        Returns:\n            OpenStreetMap URL for the location\n        \"\"\"\n        osm_url=f\"https://www.open{map_type}map.org/?mlat={self.lat}&amp;mlon={self.lon}&amp;zoom={zoom}\"\n        return osm_url\n\n    @classmethod\n    def from_record(cls, record: dict) -&gt; 'WikidataGeoItem':\n        \"\"\"\n        Create WikidataGeoItem from a dictionary record\n\n        Args:\n            record: Dictionary containing lat, lon, label and description\n\n        Returns:\n            WikidataGeoRecord instance\n        \"\"\"\n        return cls(\n            qid=record[\"qid\"],\n            lat=float(record[\"lat\"]),\n            lon=float(record[\"lon\"]),\n            label=record[\"label\"],\n            description=record[\"description\"]\n        )\n</code></pre>"},{"location":"#velorail.locfind.WikidataGeoItem.osm_url","title":"<code>osm_url: str</code>  <code>property</code>","text":"<p>Get OpenStreetMap URL for this location</p> <p>Parameters:</p> Name Type Description Default <code>zoom</code> <p>Zoom level (default=15)</p> required <p>Returns:</p> Type Description <code>str</code> <p>OpenStreetMap URL for the location</p>"},{"location":"#velorail.locfind.WikidataGeoItem.from_record","title":"<code>from_record(record)</code>  <code>classmethod</code>","text":"<p>Create WikidataGeoItem from a dictionary record</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>dict</code> <p>Dictionary containing lat, lon, label and description</p> required <p>Returns:</p> Type Description <code>WikidataGeoItem</code> <p>WikidataGeoRecord instance</p> Source code in <code>velorail/locfind.py</code> <pre><code>@classmethod\ndef from_record(cls, record: dict) -&gt; 'WikidataGeoItem':\n    \"\"\"\n    Create WikidataGeoItem from a dictionary record\n\n    Args:\n        record: Dictionary containing lat, lon, label and description\n\n    Returns:\n        WikidataGeoRecord instance\n    \"\"\"\n    return cls(\n        qid=record[\"qid\"],\n        lat=float(record[\"lat\"]),\n        lon=float(record[\"lon\"]),\n        label=record[\"label\"],\n        description=record[\"description\"]\n    )\n</code></pre>"},{"location":"#velorail.locfind.WikidataGeoItem.get_map_links","title":"<code>get_map_links(leg_styles=None, zoom=14)</code>","text":"<p>Get HTML markup with icons grouped by map type</p> Source code in <code>velorail/locfind.py</code> <pre><code>def get_map_links(self, leg_styles:Optional[LegStyles]=None, zoom:int=14) -&gt; str:\n    \"\"\"\n    Get HTML markup with icons grouped by map type\n    \"\"\"\n    if leg_styles is None:\n        leg_styles = LegStyles.default()\n\n    map_links = {\n        \"openstreetmap.org\": [\"car\", \"bus\", \"plane\"],\n        \"opencyclemap.org\": [\"bike\"],\n        \"openrailwaymap.org\": [\"train\"],\n        \"map.openseamap.org\": [\"ferry\"],\n        \"hiking.waymarkedtrails.org\": [\"foot\"]\n    }\n\n    markup = \"\"\n    delim=\"\"\n    for map_url, leg_types in map_links.items():\n        icons=\"\"\n        for leg_type in leg_types:\n            leg_style=leg_styles.get_style(leg_type)\n            icons+=leg_style.utf8_icon\n        tooltip = f\"{','.join(leg_types)} map\"\n        if \"car\" in leg_types:\n            url = f\"https://{map_url}/#map={zoom}/{self.lat}/{self.lon}\"\n        elif \"foot\" in leg_types:\n            url = f\"https://{map_url}/#?map={zoom}/{self.lat}/{self.lon}\"\n        else:\n            url = f\"https://{map_url}/?zoom={zoom}&amp;lat={self.lat}&amp;lon={self.lon}\"\n        link=Link.create(url, text=icons, tooltip=tooltip, target=\"_blank\")\n        markup+=link+delim\n        delim=\"\\n\"\n    return markup\n</code></pre>"},{"location":"#velorail.tour","title":"<code>tour</code>","text":"<p>Created on 2025-01-19</p> <p>@author: wf</p> <p>Tour definition as Legs connecting Locs Styling of Legs</p>"},{"location":"#velorail.tour.Leg","title":"<code>Leg</code>","text":"<p>A segment of a trip between two locations</p> Source code in <code>velorail/tour.py</code> <pre><code>@lod_storable\nclass Leg:\n    \"\"\"\n    A segment of a trip between two locations\n    \"\"\"\n\n    leg_type: str  # e.g., \"bike\", \"train\", \"car\"\n    start: Loc\n    end: Loc\n    url: Optional[str] = None\n</code></pre>"},{"location":"#velorail.tour.LegStyle","title":"<code>LegStyle</code>","text":"<p>Style configuration for a transport leg</p> Source code in <code>velorail/tour.py</code> <pre><code>@lod_storable\nclass LegStyle:\n    \"\"\"\n    Style configuration for a transport leg\n    \"\"\"\n\n    leg_type: str  # e.g. \"bike\", \"train\", \"car\", \"ferry\", \"bus\", \"plane\"\n    point_type: str\n    color: str\n    utf8_icon: str\n    weight: int\n    dashArray: Optional[str]\n    opacity: float\n</code></pre>"},{"location":"#velorail.tour.LegStyles","title":"<code>LegStyles</code>","text":"<p>Collection of predefined styles for different leg types</p> Source code in <code>velorail/tour.py</code> <pre><code>@lod_storable\nclass LegStyles:\n    \"\"\"\n    Collection of predefined styles for different leg types\n    \"\"\"\n\n    styles: Dict[str, LegStyle] = field(default_factory=dict)\n\n    def get_style(self, leg_type: str) -&gt; LegStyle:\n        \"\"\"\n        Get style for given leg type\n        \"\"\"\n        leg_style = self.styles.get(leg_type)\n        return leg_style\n\n    @classmethod\n    def default(cls) -&gt; \"LegStyles\":\n        \"\"\"\n        Get default leg styles\n        \"\"\"\n        default_styles = {\n            \"bike\": LegStyle(\n                leg_type=\"bike\",\n                point_type=\"knooppunt\",\n                color=\"#FF0000\",  # bike - red (avoid green due to map background)\n                utf8_icon=\"\ud83d\udeb2\",\n                weight=3,\n                dashArray=None,\n                opacity=1.0,\n            ),\n            \"train\": LegStyle(\n                leg_type=\"train\",\n                point_type=\"train_station\",\n                color=\"#555555\",  # train - dark gray (improves contrast over black)\n                utf8_icon=\"\ud83d\ude82\",\n                weight=3,\n                dashArray=\"10,10\",\n                opacity=1.0,\n            ),\n            \"car\": LegStyle(\n                leg_type=\"car\",\n                point_type=\"parking\",\n                color=\"#404040\",  # car - medium gray\n                utf8_icon=\"\ud83d\ude97\",\n                weight=3,\n                dashArray=None,\n                opacity=1.0,\n            ),\n            \"ferry\": LegStyle(\n                leg_type=\"ferry\",\n                point_type=\"ferry_terminal\",\n                color=\"#1E90FF\",  # ferry - dodger blue for visibility\n                utf8_icon=\"\u26f4\ufe0f\",\n                weight=3,\n                dashArray=\"15,10\",\n                opacity=0.8,\n            ),\n            \"foot\": LegStyle(\n               leg_type=\"foot\",\n               point_type=\"waypoint\",\n               color=\"#FFD700\", #  yellow\n               utf8_icon=\"\ud83d\udc63\",\n               weight=2,\n               dashArray=\"5,5\",\n               opacity=0.9,\n            ),\n            \"bus\": LegStyle(\n                leg_type=\"bus\",\n                point_type=\"bus_stop\",\n                color=\"#FF4500\",  # bus - orange-red for distinctiveness\n                utf8_icon=\"\ud83d\ude8c\",\n                weight=3,\n                dashArray=None,\n                opacity=1.0,\n            ),\n            \"plane\": LegStyle(\n                leg_type=\"plane\",\n                point_type=\"airport\",\n                color=\"#4B0082\",  # plane - indigo for uniqueness\n                utf8_icon=\"\u2708\ufe0f\",\n                weight=3,\n                dashArray=\"20,10,5,10\",\n                opacity=0.7,\n            ),\n        }\n        return cls(styles=default_styles)\n</code></pre>"},{"location":"#velorail.tour.LegStyles.default","title":"<code>default()</code>  <code>classmethod</code>","text":"<p>Get default leg styles</p> Source code in <code>velorail/tour.py</code> <pre><code>@classmethod\ndef default(cls) -&gt; \"LegStyles\":\n    \"\"\"\n    Get default leg styles\n    \"\"\"\n    default_styles = {\n        \"bike\": LegStyle(\n            leg_type=\"bike\",\n            point_type=\"knooppunt\",\n            color=\"#FF0000\",  # bike - red (avoid green due to map background)\n            utf8_icon=\"\ud83d\udeb2\",\n            weight=3,\n            dashArray=None,\n            opacity=1.0,\n        ),\n        \"train\": LegStyle(\n            leg_type=\"train\",\n            point_type=\"train_station\",\n            color=\"#555555\",  # train - dark gray (improves contrast over black)\n            utf8_icon=\"\ud83d\ude82\",\n            weight=3,\n            dashArray=\"10,10\",\n            opacity=1.0,\n        ),\n        \"car\": LegStyle(\n            leg_type=\"car\",\n            point_type=\"parking\",\n            color=\"#404040\",  # car - medium gray\n            utf8_icon=\"\ud83d\ude97\",\n            weight=3,\n            dashArray=None,\n            opacity=1.0,\n        ),\n        \"ferry\": LegStyle(\n            leg_type=\"ferry\",\n            point_type=\"ferry_terminal\",\n            color=\"#1E90FF\",  # ferry - dodger blue for visibility\n            utf8_icon=\"\u26f4\ufe0f\",\n            weight=3,\n            dashArray=\"15,10\",\n            opacity=0.8,\n        ),\n        \"foot\": LegStyle(\n           leg_type=\"foot\",\n           point_type=\"waypoint\",\n           color=\"#FFD700\", #  yellow\n           utf8_icon=\"\ud83d\udc63\",\n           weight=2,\n           dashArray=\"5,5\",\n           opacity=0.9,\n        ),\n        \"bus\": LegStyle(\n            leg_type=\"bus\",\n            point_type=\"bus_stop\",\n            color=\"#FF4500\",  # bus - orange-red for distinctiveness\n            utf8_icon=\"\ud83d\ude8c\",\n            weight=3,\n            dashArray=None,\n            opacity=1.0,\n        ),\n        \"plane\": LegStyle(\n            leg_type=\"plane\",\n            point_type=\"airport\",\n            color=\"#4B0082\",  # plane - indigo for uniqueness\n            utf8_icon=\"\u2708\ufe0f\",\n            weight=3,\n            dashArray=\"20,10,5,10\",\n            opacity=0.7,\n        ),\n    }\n    return cls(styles=default_styles)\n</code></pre>"},{"location":"#velorail.tour.LegStyles.get_style","title":"<code>get_style(leg_type)</code>","text":"<p>Get style for given leg type</p> Source code in <code>velorail/tour.py</code> <pre><code>def get_style(self, leg_type: str) -&gt; LegStyle:\n    \"\"\"\n    Get style for given leg type\n    \"\"\"\n    leg_style = self.styles.get(leg_type)\n    return leg_style\n</code></pre>"},{"location":"#velorail.tour.Loc","title":"<code>Loc</code>","text":"<p>A location in a trip or tour</p> Source code in <code>velorail/tour.py</code> <pre><code>@lod_storable\nclass Loc:\n    \"\"\"\n    A location in a trip or tour\n    \"\"\"\n\n    id: str\n    coordinates: Tuple[float, float]  # latlon\n    name: str\n    loc_type: Optional[str] = None\n    url: Optional[str] = None\n    notes: Optional[str] = None\n</code></pre>"},{"location":"#velorail.tour.Tour","title":"<code>Tour</code>","text":"<p>A sequence of legs connecting waypoints that form a complete journey</p> Source code in <code>velorail/tour.py</code> <pre><code>@lod_storable\nclass Tour:\n    \"\"\"\n    A sequence of legs connecting waypoints that form a complete journey\n    \"\"\"\n\n    name: str\n    legs: list[Leg] = field(default_factory=list)\n    description: Optional[str] = None\n    url: Optional[str] = None\n\n    def dump(self, limit: int = 10, leg_styles: \"LegStyles\" = None):\n        \"\"\"\n        Print a detailed dump of the tour for debugging\n\n        Args:\n           limit: Maximum number of legs to show\n        \"\"\"\n        if leg_styles is None:\n            leg_styles = LegStyles.default()\n        print(f\"Tour: {self.name}\")\n        for i, leg in enumerate(self.legs):\n            if i &gt;= limit:\n                remaining = len(self.legs) - limit\n                print(f\"... {remaining} more legs\")\n                break\n            leg_style = leg_styles.get_style(leg.leg_type)\n            if leg_style:\n                utf8_icon = leg_style.utf8_icon\n            else:\n                utf8_icon = \"?\"\n            coord_start = (\n                f\"({leg.start.coordinates[0]:.5f}, {leg.start.coordinates[1]:.5f})\"\n            )\n            coord_end = f\"({leg.end.coordinates[0]:.5f}, {leg.end.coordinates[1]:.5f})\"\n            print(f\" {utf8_icon} {coord_start} \u279c {coord_end}\")\n</code></pre>"},{"location":"#velorail.tour.Tour.dump","title":"<code>dump(limit=10, leg_styles=None)</code>","text":"<p>Print a detailed dump of the tour for debugging</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>Maximum number of legs to show</p> <code>10</code> Source code in <code>velorail/tour.py</code> <pre><code>def dump(self, limit: int = 10, leg_styles: \"LegStyles\" = None):\n    \"\"\"\n    Print a detailed dump of the tour for debugging\n\n    Args:\n       limit: Maximum number of legs to show\n    \"\"\"\n    if leg_styles is None:\n        leg_styles = LegStyles.default()\n    print(f\"Tour: {self.name}\")\n    for i, leg in enumerate(self.legs):\n        if i &gt;= limit:\n            remaining = len(self.legs) - limit\n            print(f\"... {remaining} more legs\")\n            break\n        leg_style = leg_styles.get_style(leg.leg_type)\n        if leg_style:\n            utf8_icon = leg_style.utf8_icon\n        else:\n            utf8_icon = \"?\"\n        coord_start = (\n            f\"({leg.start.coordinates[0]:.5f}, {leg.start.coordinates[1]:.5f})\"\n        )\n        coord_end = f\"({leg.end.coordinates[0]:.5f}, {leg.end.coordinates[1]:.5f})\"\n        print(f\" {utf8_icon} {coord_start} \u279c {coord_end}\")\n</code></pre>"},{"location":"#velorail.velorail_cmd","title":"<code>velorail_cmd</code>","text":"<p>Created on 2025-02-01</p> <p>@author: wf</p>"},{"location":"#velorail.velorail_cmd.VeloRailCmd","title":"<code>VeloRailCmd</code>","text":"<p>               Bases: <code>WebserverCmd</code></p> <p>command line handling for velorail</p> Source code in <code>velorail/velorail_cmd.py</code> <pre><code>class VeloRailCmd(WebserverCmd):\n    \"\"\"\n    command line handling for velorail\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        constructor\n        \"\"\"\n        config = VeloRailWebServer.get_config()\n        WebserverCmd.__init__(self, config, VeloRailWebServer)\n        pass\n\n    def getArgParser(self, description: str, version_msg) -&gt; ArgumentParser:\n        \"\"\"\n        override the default argparser call\n        \"\"\"\n        parser = super().getArgParser(description, version_msg)\n        parser.add_argument(\n            \"-en\",\n            \"--endpointName\",\n            default=\"wikidata\",\n            help=f\"Name of the endpoint to use for queries. Available by default: {EndpointManager.getEndpointNames(lang='sparql')}\",\n        )\n        parser.add_argument(\n            \"-v\",\n            \"--verbose\",\n            action=\"store_true\",\n            help=\"show verbose output [default: %(default)s]\",\n        )\n        parser.add_argument(\n            \"-rp\",\n            \"--root_path\",\n            default=VeloRailWebServer.examples_path(),\n            help=\"path to velorail files [default: %(default)s]\",\n        )\n        parser.add_argument(\"--gpx\", required=False, help=\"URL or path to GPX file\")\n        parser.add_argument(\n            \"--token\", required=False, help=\"Authentication token for GPX access\"\n        )\n        parser.add_argument(\n            \"--zoom\",\n            type=int,\n            default=GPXViewer.default_zoom,\n            help=\"zoom level (default: 11)\",\n        )\n        parser.add_argument(\n            \"--center\",\n            nargs=2,\n            type=float,\n            default=GPXViewer.default_center,\n            help=\"center lat,lon - default: Greenwich\",\n        )\n        return parser\n</code></pre>"},{"location":"#velorail.velorail_cmd.VeloRailCmd.__init__","title":"<code>__init__()</code>","text":"<p>constructor</p> Source code in <code>velorail/velorail_cmd.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    constructor\n    \"\"\"\n    config = VeloRailWebServer.get_config()\n    WebserverCmd.__init__(self, config, VeloRailWebServer)\n    pass\n</code></pre>"},{"location":"#velorail.velorail_cmd.VeloRailCmd.getArgParser","title":"<code>getArgParser(description, version_msg)</code>","text":"<p>override the default argparser call</p> Source code in <code>velorail/velorail_cmd.py</code> <pre><code>def getArgParser(self, description: str, version_msg) -&gt; ArgumentParser:\n    \"\"\"\n    override the default argparser call\n    \"\"\"\n    parser = super().getArgParser(description, version_msg)\n    parser.add_argument(\n        \"-en\",\n        \"--endpointName\",\n        default=\"wikidata\",\n        help=f\"Name of the endpoint to use for queries. Available by default: {EndpointManager.getEndpointNames(lang='sparql')}\",\n    )\n    parser.add_argument(\n        \"-v\",\n        \"--verbose\",\n        action=\"store_true\",\n        help=\"show verbose output [default: %(default)s]\",\n    )\n    parser.add_argument(\n        \"-rp\",\n        \"--root_path\",\n        default=VeloRailWebServer.examples_path(),\n        help=\"path to velorail files [default: %(default)s]\",\n    )\n    parser.add_argument(\"--gpx\", required=False, help=\"URL or path to GPX file\")\n    parser.add_argument(\n        \"--token\", required=False, help=\"Authentication token for GPX access\"\n    )\n    parser.add_argument(\n        \"--zoom\",\n        type=int,\n        default=GPXViewer.default_zoom,\n        help=\"zoom level (default: 11)\",\n    )\n    parser.add_argument(\n        \"--center\",\n        nargs=2,\n        type=float,\n        default=GPXViewer.default_center,\n        help=\"center lat,lon - default: Greenwich\",\n    )\n    return parser\n</code></pre>"},{"location":"#velorail.velorail_cmd.main","title":"<code>main(argv=None)</code>","text":"<p>main call</p> Source code in <code>velorail/velorail_cmd.py</code> <pre><code>def main(argv: list = None):\n    \"\"\"\n    main call\n    \"\"\"\n    cmd = VeloRailCmd()\n    exit_code = cmd.cmd_main(argv)\n    return exit_code\n</code></pre>"},{"location":"#velorail.version","title":"<code>version</code>","text":"<p>Created on 2025-02-01</p> <p>@author: wf</p>"},{"location":"#velorail.version.Version","title":"<code>Version</code>  <code>dataclass</code>","text":"<p>Version handling for velorail</p> Source code in <code>velorail/version.py</code> <pre><code>@dataclass\nclass Version:\n    \"\"\"\n    Version handling for velorail\n    \"\"\"\n\n    name = \"velorail\"\n    version = velorail.__version__\n    date = \"2025-02-01\"\n    updated = \"2025-02-01\"\n    description = \"Multimodal bike and train route planning support\"\n\n    authors = \"Wolfgang Fahl\"\n\n    doc_url = \"https://wiki.bitplan.com/index.php/velorail\"\n    chat_url = \"https://github.com/WolfgangFahl/velorail/discussions\"\n    cm_url = \"https://github.com/WolfgangFahl/velorail\"\n\n    license = f\"\"\"Copyright 2025 contributors. All rights reserved.\n\n  Licensed under the Apache License 2.0\n  http://www.apache.org/licenses/LICENSE-2.0\n\n  Distributed on an \"AS IS\" basis without warranties\n  or conditions of any kind, either express or implied.\"\"\"\n\n    longDescription = f\"\"\"{name} version {version}\n{description}\n\n  Created by {authors} on {date} last updated {updated}\"\"\"\n</code></pre>"},{"location":"#velorail.wditem_search","title":"<code>wditem_search</code>","text":"<p>Created on 2024-01-03</p> <p>@author: wf</p>"},{"location":"#velorail.wditem_search.WikidataItemSearch","title":"<code>WikidataItemSearch</code>","text":"<p>wikidata item search</p> Source code in <code>velorail/wditem_search.py</code> <pre><code>class WikidataItemSearch:\n    \"\"\"\n    wikidata item search\n    \"\"\"\n\n    def __init__(\n        self, solution: WebSolution, record_filter: Callable = None, lang: str = \"en\"\n    ):\n        \"\"\"\n        Initialize the WikidataItemSearch with the given solution.\n\n        Args:\n            solution (WebSolution): The solution to attach the search UI.\n            record_filter(Callable): callback for displayed found records\n        \"\"\"\n        self.solution = solution\n        self.lang = lang\n        # Get available languages\n        self.languages = Lang.get_language_dict()\n        self.record_filter = record_filter\n        self.limit = 9\n        self.wd_search = WikidataSearch(lang)\n        self.search_debounce_task = None\n        self.keyStrokeTime = 0.65  # minimum time in seconds to wait between keystrokes before starting searching\n        self.search_result_row = None\n        self.setup()\n\n    def setup(self):\n        \"\"\"\n        setup the user interface\n        \"\"\"\n        with ui.card().style(\"width: 25%\"):\n            with ui.grid(rows=1, columns=4):\n                # Create a label to display the chosen language with the default language\n                self.lang_label = ui.label(self.lang)\n                # Create a dropdown for language selection with the default language selected\n                # Bind the label text to the selection's value, so it updates automatically\n                ui.select(self.languages, value=self.lang).bind_value(\n                    self.lang_label, \"text\"\n                )\n                ui.label(\"limit:\")\n                self.limit_slider = (\n                    ui.slider(min=2, max=50, value=self.limit)\n                    .props(\"label-always\")\n                    .bind_value(self, \"limit\")\n                )\n            with ui.row():\n                self.search_input = ui.input(\n                    label=\"search\", on_change=self.on_search_change\n                ).props(\"size=80\")\n        with ui.row() as self.search_result_row:\n            self.search_result_grid = ListOfDictsGrid()\n\n    async def on_search_change(self, _args):\n        \"\"\"\n        react on changes in the search input\n        \"\"\"\n        # Cancel the existing search task if it's still waiting\n        if self.search_debounce_task:\n            self.search_debounce_task.cancel()\n\n        # Create a new task for the new search\n        self.search_debounce_task = asyncio.create_task(self.debounced_search())\n\n    async def debounced_search(self):\n        \"\"\"\n        Waits for a period of inactivity and then performs the search.\n        \"\"\"\n        try:\n            # Wait for the debounce period (keyStrokeTime)\n            await asyncio.sleep(self.keyStrokeTime)\n            search_for = self.search_input.value\n            if self.search_result_row:\n                with self.search_result_row:\n                    lang = self.lang_label.text\n                    ui.notify(f\"searching wikidata for {search_for} ({lang})...\")\n                    self.wd_search.language = lang\n                    wd_search_result = self.wd_search.searchOptions(\n                        search_for, limit=self.limit\n                    )\n                    view_lod = self.get_selection_view_lod(wd_search_result)\n                    self.search_result_grid.load_lod(view_lod)\n                    # self.search_result_grid.set_checkbox_selection(\"#\")\n                    self.search_result_grid.update()\n        except asyncio.CancelledError:\n            # The search was cancelled because of new input, so just quietly exit\n            pass\n        except BaseException as ex:\n            self.solution.handle_exception(ex)\n\n    def get_selection_view_lod(self, wd_search_result: list) -&gt; dict:\n        \"\"\"\n        Convert the Wikidata search result list of dict to a selection.\n\n        Args:\n            wd_search_result (List[Dict[str, Any]]): The search results from Wikidata.\n\n        Returns:\n            List[Dict[str, Any]]: The list of dictionaries formatted for view.\n        \"\"\"\n        view_lod = []\n        for qid, itemLabel, desc in wd_search_result:\n            url = f\"https://www.wikidata.org/wiki/{qid}\"\n            link = Link.create(url, qid)\n            row = {\n                \"#\": len(view_lod) + 1,\n                \"qid\": link,\n                \"label\": itemLabel,\n                \"desc\": desc,\n            }\n            if self.record_filter:\n                self.record_filter(qid, row)\n            view_lod.append(row)\n        return view_lod\n</code></pre>"},{"location":"#velorail.wditem_search.WikidataItemSearch.__init__","title":"<code>__init__(solution, record_filter=None, lang='en')</code>","text":"<p>Initialize the WikidataItemSearch with the given solution.</p> <p>Parameters:</p> Name Type Description Default <code>solution</code> <code>WebSolution</code> <p>The solution to attach the search UI.</p> required <code>record_filter(Callable)</code> <p>callback for displayed found records</p> required Source code in <code>velorail/wditem_search.py</code> <pre><code>def __init__(\n    self, solution: WebSolution, record_filter: Callable = None, lang: str = \"en\"\n):\n    \"\"\"\n    Initialize the WikidataItemSearch with the given solution.\n\n    Args:\n        solution (WebSolution): The solution to attach the search UI.\n        record_filter(Callable): callback for displayed found records\n    \"\"\"\n    self.solution = solution\n    self.lang = lang\n    # Get available languages\n    self.languages = Lang.get_language_dict()\n    self.record_filter = record_filter\n    self.limit = 9\n    self.wd_search = WikidataSearch(lang)\n    self.search_debounce_task = None\n    self.keyStrokeTime = 0.65  # minimum time in seconds to wait between keystrokes before starting searching\n    self.search_result_row = None\n    self.setup()\n</code></pre>"},{"location":"#velorail.wditem_search.WikidataItemSearch.debounced_search","title":"<code>debounced_search()</code>  <code>async</code>","text":"<p>Waits for a period of inactivity and then performs the search.</p> Source code in <code>velorail/wditem_search.py</code> <pre><code>async def debounced_search(self):\n    \"\"\"\n    Waits for a period of inactivity and then performs the search.\n    \"\"\"\n    try:\n        # Wait for the debounce period (keyStrokeTime)\n        await asyncio.sleep(self.keyStrokeTime)\n        search_for = self.search_input.value\n        if self.search_result_row:\n            with self.search_result_row:\n                lang = self.lang_label.text\n                ui.notify(f\"searching wikidata for {search_for} ({lang})...\")\n                self.wd_search.language = lang\n                wd_search_result = self.wd_search.searchOptions(\n                    search_for, limit=self.limit\n                )\n                view_lod = self.get_selection_view_lod(wd_search_result)\n                self.search_result_grid.load_lod(view_lod)\n                # self.search_result_grid.set_checkbox_selection(\"#\")\n                self.search_result_grid.update()\n    except asyncio.CancelledError:\n        # The search was cancelled because of new input, so just quietly exit\n        pass\n    except BaseException as ex:\n        self.solution.handle_exception(ex)\n</code></pre>"},{"location":"#velorail.wditem_search.WikidataItemSearch.get_selection_view_lod","title":"<code>get_selection_view_lod(wd_search_result)</code>","text":"<p>Convert the Wikidata search result list of dict to a selection.</p> <p>Parameters:</p> Name Type Description Default <code>wd_search_result</code> <code>List[Dict[str, Any]]</code> <p>The search results from Wikidata.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>List[Dict[str, Any]]: The list of dictionaries formatted for view.</p> Source code in <code>velorail/wditem_search.py</code> <pre><code>def get_selection_view_lod(self, wd_search_result: list) -&gt; dict:\n    \"\"\"\n    Convert the Wikidata search result list of dict to a selection.\n\n    Args:\n        wd_search_result (List[Dict[str, Any]]): The search results from Wikidata.\n\n    Returns:\n        List[Dict[str, Any]]: The list of dictionaries formatted for view.\n    \"\"\"\n    view_lod = []\n    for qid, itemLabel, desc in wd_search_result:\n        url = f\"https://www.wikidata.org/wiki/{qid}\"\n        link = Link.create(url, qid)\n        row = {\n            \"#\": len(view_lod) + 1,\n            \"qid\": link,\n            \"label\": itemLabel,\n            \"desc\": desc,\n        }\n        if self.record_filter:\n            self.record_filter(qid, row)\n        view_lod.append(row)\n    return view_lod\n</code></pre>"},{"location":"#velorail.wditem_search.WikidataItemSearch.on_search_change","title":"<code>on_search_change(_args)</code>  <code>async</code>","text":"<p>react on changes in the search input</p> Source code in <code>velorail/wditem_search.py</code> <pre><code>async def on_search_change(self, _args):\n    \"\"\"\n    react on changes in the search input\n    \"\"\"\n    # Cancel the existing search task if it's still waiting\n    if self.search_debounce_task:\n        self.search_debounce_task.cancel()\n\n    # Create a new task for the new search\n    self.search_debounce_task = asyncio.create_task(self.debounced_search())\n</code></pre>"},{"location":"#velorail.wditem_search.WikidataItemSearch.setup","title":"<code>setup()</code>","text":"<p>setup the user interface</p> Source code in <code>velorail/wditem_search.py</code> <pre><code>def setup(self):\n    \"\"\"\n    setup the user interface\n    \"\"\"\n    with ui.card().style(\"width: 25%\"):\n        with ui.grid(rows=1, columns=4):\n            # Create a label to display the chosen language with the default language\n            self.lang_label = ui.label(self.lang)\n            # Create a dropdown for language selection with the default language selected\n            # Bind the label text to the selection's value, so it updates automatically\n            ui.select(self.languages, value=self.lang).bind_value(\n                self.lang_label, \"text\"\n            )\n            ui.label(\"limit:\")\n            self.limit_slider = (\n                ui.slider(min=2, max=50, value=self.limit)\n                .props(\"label-always\")\n                .bind_value(self, \"limit\")\n            )\n        with ui.row():\n            self.search_input = ui.input(\n                label=\"search\", on_change=self.on_search_change\n            ).props(\"size=80\")\n    with ui.row() as self.search_result_row:\n        self.search_result_grid = ListOfDictsGrid()\n</code></pre>"},{"location":"#velorail.webserver","title":"<code>webserver</code>","text":"<p>Created on 2025-02-01</p> <p>@author: wf</p>"},{"location":"#velorail.webserver.VeloRailSolution","title":"<code>VeloRailSolution</code>","text":"<p>               Bases: <code>InputWebSolution</code></p> <p>the VeloRail solution</p> Source code in <code>velorail/webserver.py</code> <pre><code>class VeloRailSolution(InputWebSolution):\n    \"\"\"\n    the VeloRail solution\n    \"\"\"\n\n    def __init__(self, webserver: \"VeloRailWebServer\", client: Client):\n        \"\"\"\n        Initialize the solution\n\n        Calls the constructor of the base solution\n        Args:\n            webserver (VeloRailWebServer): The webserver instance associated with this context.\n            client (Client): The client instance this context is associated with.\n        \"\"\"\n        super().__init__(webserver, client)  # Call to the superclass constructor\n        self.args = self.webserver.args\n        self.viewer = GPXViewer(args=self.args)\n\n    def clean_smw_artifacts(self, input_str: str) -&gt; str:\n        \"\"\"\n        Remove SMW artifacts ([[SMW::on]] and [[SMW::off]]) from the input string.\n\n        Args:\n            input_str (str): Input string containing SMW artifacts.\n\n        Returns:\n            str: Cleaned string without SMW markers.\n        \"\"\"\n        # Regex to match and remove SMW markers\n        return re.sub(r\"\\[\\[SMW::(on|off)\\]\\]\", \"\", input_str)\n\n    async def show_wikidata_item(\n        self,\n        qid: str = None\n    ):\n        \"\"\"\n        show the given wikidata item on the map\n        Args:\n            qid(str): the Wikidata id of the item to analyze\n        \"\"\"\n        def show():\n            viewer=self.viewer\n            # Create LocFinder and get coordinates\n            locfinder = LocFinder()\n            center=None\n            wd_item = locfinder.get_wikidata_geo(qid)\n            if wd_item:\n                wd_link=wd_item.as_wd_link()\n                wd_maps=wd_item.get_map_links(zoom=self.viewer.zoom)\n                # create markup with links\n                markup=f\"{wd_link}&amp;nbsp;{wd_maps}\"\n                ui.html(markup)\n                center = [wd_item.lat, wd_item.lon]\n            viewer.show(center=center)\n\n        await self.setup_content_div(show)\n\n    async def show_lines(\n        self,\n        lines: str = None,\n        auth_token: str = None,\n        zoom: int = GPXViewer.default_zoom,\n    ):\n        \"\"\"\n        Endpoint to display routes based on 'lines' parameter.\n        \"\"\"\n        if not self.viewer:\n            ui.label(\"Error: Viewer not initialized\")\n            return\n\n        if self.viewer.args.token and auth_token != self.viewer.args.token:\n            ui.label(\"Error: Invalid authentication token\")\n            return\n\n        if not lines:\n            ui.label(\"Error: No 'lines' parameter provided\")\n            return\n\n        # Clean the lines parameter to remove SMW artifacts\n        cleaned_lines = self.clean_smw_artifacts(lines)\n\n        # Delegate logic to GPXViewer\n        try:\n            self.viewer.parse_lines_and_show(cleaned_lines, zoom=zoom)\n        except ValueError as e:\n            ui.label(f\"Error processing lines: {e}\")\n\n    async def show_gpx(\n        self,\n        gpx: str = None,\n        auth_token: str = None,\n        zoom: int = GPXViewer.default_zoom,\n    ):\n        \"\"\"\n        GPX viewer page with optional gpx_url and auth_token.\n        \"\"\"\n        viewer = self.viewer\n        if not viewer:\n            ui.label(\"Error: Viewer not initialized\")\n            return\n\n        if viewer.args.token and auth_token != viewer.args.token:\n            ui.label(\"Error: Invalid authentication token\")\n            return\n\n        gpx_to_use = gpx if gpx else viewer.args.gpx\n        if gpx_to_use:\n            viewer.load_gpx(gpx_to_use)\n            viewer.show(zoom=zoom)\n        else:\n            ui.label(\n                \"Please provide a GPX file via 'gpx' query parameter or the command line.\"\n            )\n\n    def prepare_ui(self):\n        \"\"\"\n        overrideable configuration\n        \"\"\"\n        self.endpoint_name = self.args.endpointName\n        self.lang = \"en\"  # FIXME make configurable\n\n    async def home(self):\n        \"\"\"\n        provide the main content page\n        \"\"\"\n\n        def record_filter(qid: str, record: dict):\n            \"\"\"\n            filter the given search record\n            \"\"\"\n            if \"label\" and \"desc\" in record:\n                desc=record[\"desc\"]\n                label=record[\"label\"]\n                text = f\"\"\"{label}({qid})\u261e{desc}\"\"\"\n                map_link = Link.create(f\"/wd/{qid}\", text)\n                # getting the link to be at second position\n                # is a bit tricky\n                temp_items = list(record.items())\n                # Add the new item in the second position\n                temp_items.insert(1, (\"map\", map_link))\n\n                # Clear the original dictionary and update it with the new order of items\n                record.clear()\n                record.update(temp_items)\n\n        def show():\n            self.wd_item_search = WikidataItemSearch(\n                self, record_filter=record_filter, lang=self.lang\n            )\n\n        await self.setup_content_div(show)\n</code></pre>"},{"location":"#velorail.webserver.VeloRailSolution.__init__","title":"<code>__init__(webserver, client)</code>","text":"<p>Initialize the solution</p> <p>Calls the constructor of the base solution Args:     webserver (VeloRailWebServer): The webserver instance associated with this context.     client (Client): The client instance this context is associated with.</p> Source code in <code>velorail/webserver.py</code> <pre><code>def __init__(self, webserver: \"VeloRailWebServer\", client: Client):\n    \"\"\"\n    Initialize the solution\n\n    Calls the constructor of the base solution\n    Args:\n        webserver (VeloRailWebServer): The webserver instance associated with this context.\n        client (Client): The client instance this context is associated with.\n    \"\"\"\n    super().__init__(webserver, client)  # Call to the superclass constructor\n    self.args = self.webserver.args\n    self.viewer = GPXViewer(args=self.args)\n</code></pre>"},{"location":"#velorail.webserver.VeloRailSolution.clean_smw_artifacts","title":"<code>clean_smw_artifacts(input_str)</code>","text":"<p>Remove SMW artifacts ([[SMW::on]] and [[SMW::off]]) from the input string.</p> <p>Parameters:</p> Name Type Description Default <code>input_str</code> <code>str</code> <p>Input string containing SMW artifacts.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Cleaned string without SMW markers.</p> Source code in <code>velorail/webserver.py</code> <pre><code>def clean_smw_artifacts(self, input_str: str) -&gt; str:\n    \"\"\"\n    Remove SMW artifacts ([[SMW::on]] and [[SMW::off]]) from the input string.\n\n    Args:\n        input_str (str): Input string containing SMW artifacts.\n\n    Returns:\n        str: Cleaned string without SMW markers.\n    \"\"\"\n    # Regex to match and remove SMW markers\n    return re.sub(r\"\\[\\[SMW::(on|off)\\]\\]\", \"\", input_str)\n</code></pre>"},{"location":"#velorail.webserver.VeloRailSolution.home","title":"<code>home()</code>  <code>async</code>","text":"<p>provide the main content page</p> Source code in <code>velorail/webserver.py</code> <pre><code>async def home(self):\n    \"\"\"\n    provide the main content page\n    \"\"\"\n\n    def record_filter(qid: str, record: dict):\n        \"\"\"\n        filter the given search record\n        \"\"\"\n        if \"label\" and \"desc\" in record:\n            desc=record[\"desc\"]\n            label=record[\"label\"]\n            text = f\"\"\"{label}({qid})\u261e{desc}\"\"\"\n            map_link = Link.create(f\"/wd/{qid}\", text)\n            # getting the link to be at second position\n            # is a bit tricky\n            temp_items = list(record.items())\n            # Add the new item in the second position\n            temp_items.insert(1, (\"map\", map_link))\n\n            # Clear the original dictionary and update it with the new order of items\n            record.clear()\n            record.update(temp_items)\n\n    def show():\n        self.wd_item_search = WikidataItemSearch(\n            self, record_filter=record_filter, lang=self.lang\n        )\n\n    await self.setup_content_div(show)\n</code></pre>"},{"location":"#velorail.webserver.VeloRailSolution.prepare_ui","title":"<code>prepare_ui()</code>","text":"<p>overrideable configuration</p> Source code in <code>velorail/webserver.py</code> <pre><code>def prepare_ui(self):\n    \"\"\"\n    overrideable configuration\n    \"\"\"\n    self.endpoint_name = self.args.endpointName\n    self.lang = \"en\"  # FIXME make configurable\n</code></pre>"},{"location":"#velorail.webserver.VeloRailSolution.show_gpx","title":"<code>show_gpx(gpx=None, auth_token=None, zoom=GPXViewer.default_zoom)</code>  <code>async</code>","text":"<p>GPX viewer page with optional gpx_url and auth_token.</p> Source code in <code>velorail/webserver.py</code> <pre><code>async def show_gpx(\n    self,\n    gpx: str = None,\n    auth_token: str = None,\n    zoom: int = GPXViewer.default_zoom,\n):\n    \"\"\"\n    GPX viewer page with optional gpx_url and auth_token.\n    \"\"\"\n    viewer = self.viewer\n    if not viewer:\n        ui.label(\"Error: Viewer not initialized\")\n        return\n\n    if viewer.args.token and auth_token != viewer.args.token:\n        ui.label(\"Error: Invalid authentication token\")\n        return\n\n    gpx_to_use = gpx if gpx else viewer.args.gpx\n    if gpx_to_use:\n        viewer.load_gpx(gpx_to_use)\n        viewer.show(zoom=zoom)\n    else:\n        ui.label(\n            \"Please provide a GPX file via 'gpx' query parameter or the command line.\"\n        )\n</code></pre>"},{"location":"#velorail.webserver.VeloRailSolution.show_lines","title":"<code>show_lines(lines=None, auth_token=None, zoom=GPXViewer.default_zoom)</code>  <code>async</code>","text":"<p>Endpoint to display routes based on 'lines' parameter.</p> Source code in <code>velorail/webserver.py</code> <pre><code>async def show_lines(\n    self,\n    lines: str = None,\n    auth_token: str = None,\n    zoom: int = GPXViewer.default_zoom,\n):\n    \"\"\"\n    Endpoint to display routes based on 'lines' parameter.\n    \"\"\"\n    if not self.viewer:\n        ui.label(\"Error: Viewer not initialized\")\n        return\n\n    if self.viewer.args.token and auth_token != self.viewer.args.token:\n        ui.label(\"Error: Invalid authentication token\")\n        return\n\n    if not lines:\n        ui.label(\"Error: No 'lines' parameter provided\")\n        return\n\n    # Clean the lines parameter to remove SMW artifacts\n    cleaned_lines = self.clean_smw_artifacts(lines)\n\n    # Delegate logic to GPXViewer\n    try:\n        self.viewer.parse_lines_and_show(cleaned_lines, zoom=zoom)\n    except ValueError as e:\n        ui.label(f\"Error processing lines: {e}\")\n</code></pre>"},{"location":"#velorail.webserver.VeloRailSolution.show_wikidata_item","title":"<code>show_wikidata_item(qid=None)</code>  <code>async</code>","text":"<p>show the given wikidata item on the map Args:     qid(str): the Wikidata id of the item to analyze</p> Source code in <code>velorail/webserver.py</code> <pre><code>async def show_wikidata_item(\n    self,\n    qid: str = None\n):\n    \"\"\"\n    show the given wikidata item on the map\n    Args:\n        qid(str): the Wikidata id of the item to analyze\n    \"\"\"\n    def show():\n        viewer=self.viewer\n        # Create LocFinder and get coordinates\n        locfinder = LocFinder()\n        center=None\n        wd_item = locfinder.get_wikidata_geo(qid)\n        if wd_item:\n            wd_link=wd_item.as_wd_link()\n            wd_maps=wd_item.get_map_links(zoom=self.viewer.zoom)\n            # create markup with links\n            markup=f\"{wd_link}&amp;nbsp;{wd_maps}\"\n            ui.html(markup)\n            center = [wd_item.lat, wd_item.lon]\n        viewer.show(center=center)\n\n    await self.setup_content_div(show)\n</code></pre>"},{"location":"#velorail.webserver.VeloRailWebServer","title":"<code>VeloRailWebServer</code>","text":"<p>               Bases: <code>InputWebserver</code></p> <p>WebServer class that manages the server for velorail</p> Source code in <code>velorail/webserver.py</code> <pre><code>class VeloRailWebServer(InputWebserver):\n    \"\"\"WebServer class that manages the server for velorail\"\"\"\n\n    @classmethod\n    def get_config(cls) -&gt; WebserverConfig:\n        copy_right = \"(c)2025 velorail team\"\n        config = WebserverConfig(\n            copy_right=copy_right,\n            version=Version(),\n            default_port=9876,\n            short_name=\"velorail\",\n        )\n        server_config = WebserverConfig.get(config)\n        server_config.solution_class = VeloRailSolution\n        return server_config\n\n    def __init__(self):\n        \"\"\"Constructs all the necessary attributes for the WebServer object.\"\"\"\n        InputWebserver.__init__(self, config=VeloRailWebServer.get_config())\n\n        @ui.page(\"/wd/{qid}\")\n        async def wikidata_item_page(client: Client, qid: str):\n            \"\"\"\n            show the given wikidata item on the map\n            \"\"\"\n            await self.page(\n                client,VeloRailSolution.show_wikidata_item, qid\n            )\n\n        @ui.page(\"/lines\")\n        async def lines_page(\n            client: Client,\n            lines: str = None,\n            auth_token: str = None,\n            zoom: int = GPXViewer.default_zoom,\n        ):\n            \"\"\"\n            Endpoint to display routes based on 'lines' parameter.\n            \"\"\"\n            await self.page(\n                client, VeloRailSolution.show_lines, lines, auth_token, zoom\n            )\n\n        @ui.page(\"/gpx\")\n        async def gpx_page(\n            client: Client,\n            gpx: str = None,\n            auth_token: str = None,\n            zoom: int = GPXViewer.default_zoom,\n        ):\n            \"\"\"\n            GPX viewer page with optional gpx_url and auth_token.\n            \"\"\"\n            await self.page(client, VeloRailSolution.show_gpx, gpx, auth_token, zoom)\n\n    def configure_run(self):\n        root_path = (\n            self.args.root_path\n            if self.args.root_path\n            else VeloRailWebServer.examples_path()\n        )\n        self.root_path = os.path.abspath(root_path)\n        self.allowed_urls = [\n            \"https://raw.githubusercontent.com/WolfgangFahl/velorail/main/velorail_examples/\",\n            self.examples_path(),\n            self.root_path,\n        ]\n\n    @classmethod\n    def examples_path(cls) -&gt; str:\n        # the root directory (default: examples)\n        path = os.path.join(os.path.dirname(__file__), \"../velorail_examples\")\n        path = os.path.abspath(path)\n        return path\n</code></pre>"},{"location":"#velorail.webserver.VeloRailWebServer.__init__","title":"<code>__init__()</code>","text":"<p>Constructs all the necessary attributes for the WebServer object.</p> Source code in <code>velorail/webserver.py</code> <pre><code>def __init__(self):\n    \"\"\"Constructs all the necessary attributes for the WebServer object.\"\"\"\n    InputWebserver.__init__(self, config=VeloRailWebServer.get_config())\n\n    @ui.page(\"/wd/{qid}\")\n    async def wikidata_item_page(client: Client, qid: str):\n        \"\"\"\n        show the given wikidata item on the map\n        \"\"\"\n        await self.page(\n            client,VeloRailSolution.show_wikidata_item, qid\n        )\n\n    @ui.page(\"/lines\")\n    async def lines_page(\n        client: Client,\n        lines: str = None,\n        auth_token: str = None,\n        zoom: int = GPXViewer.default_zoom,\n    ):\n        \"\"\"\n        Endpoint to display routes based on 'lines' parameter.\n        \"\"\"\n        await self.page(\n            client, VeloRailSolution.show_lines, lines, auth_token, zoom\n        )\n\n    @ui.page(\"/gpx\")\n    async def gpx_page(\n        client: Client,\n        gpx: str = None,\n        auth_token: str = None,\n        zoom: int = GPXViewer.default_zoom,\n    ):\n        \"\"\"\n        GPX viewer page with optional gpx_url and auth_token.\n        \"\"\"\n        await self.page(client, VeloRailSolution.show_gpx, gpx, auth_token, zoom)\n</code></pre>"}]}